---
layout: distill
title: 【论文笔记之 PYIN】PYIN, A Fundamental Frequency Estimator Using Probabilistic Threshold Distributions
date: 2024-12-15
description: 本文对 Matthias Mauch 和 Simon Dixon 等人于 2014 年在 ICASSP 上发表的论文进行简单地翻译。如有表述不当之处欢迎批评指正。欢迎任何形式的转载，但请务必注明出处。
tags: pitch pyin
categories: 论文笔记
toc:
  - name: 1. 论文目的
  - name: 2. 摘要
  - name: 3. 介绍
  - name: 4. 方法
    subsections:
      - name: 4.1. 候选值
      - name: 4.2. 音高追踪
  - name: 5. 结果
    subsections:
      - name: 5.1. 对合成数据的定量分析
      - name: 5.2. 真实的人声歌唱
  - name: 6. 结论
---

**论文链接**：[https://www.eecs.qmul.ac.uk/~simond/pub/2014/MauchDixon-PYIN-ICASSP2014.pdf](https://www.eecs.qmul.ac.uk/~simond/pub/2014/MauchDixon-PYIN-ICASSP2014.pdf)

## 1. 论文目的
提出一种改进的 YIN 算法—PYIN，其估计基频的效果更好。

## 2. 摘要
我们提出了一种用于基频估计的  Probabilistic YIN（PYIN） 算法，它是在 YIN 算法上改进而来的。传统 YIN 算法是一种简单有效的逐帧单通道的 F0 估计方法，并且仍是该领域流行的算法之一。为了消除个别误差，通常会对频率估计器的输出做后处理，来得到更加平滑的音高轨迹。YIN 算法的缺点之一是它对于每帧音频只输出一个估计值，限制了后处理的发挥空间。为了解决这个问题，我们改进了 YIN，以使其输出多个与概率相关的音高候选值（PYIN 算法的第一个阶段）。这些概率来自于 YIN 阈值参数的先验分布。我们将这些概率作为隐马尔可夫模型中的观测概率，使用维特比算法对其解码以得到改进的音高轨迹（PYIN 算法的第二个阶段）。我们证明了将两个阶段结合可以显著提升召回率和精确率。PYIN 相比于 YIN 所增加的计算复杂度是较低的。我们在网站上开源了其 [C++ 代码](https://code.soundsoftware.ac.uk/projects/pyin)。

## 3. 介绍
从单通道人声信号中估计基频（F0）是综合分析语音和歌唱中的语调的先决条件。由于逐帧音高估计不完全可靠，因此，经常使用后处理来提升原始的音高轨迹。尽管已有算法的成功率很高，但该过程通常存在缺陷，因为在逐帧估计阶段所丢弃的频率候选值无法在平滑阶段恢复，因此，在进行后处理平滑之前，应该使用多个逐帧音高候选值。

在语音处理领域，研究者们已经提出了很多 F0 估计方法。在这些方法中，YIN 算法在语音处理领域之外也很受欢迎，尤其是在歌唱分析方面。Babacan 等人比较了 F0 估计算法在歌唱方面的性能，结果显示 YIN 算法是效果最好的，而且特别擅长精细的音高识别。

原始的 YIN 算法论文提到了一个不使用逐帧估计，而是追踪基础周期性函数的低值的平滑过程。在本文中，我们在 YIN 的基础上，以概率的方式修改了其逐帧估计过程，输出了多个与概率相关的音高候选值，因此减少了平滑之前有用信息的损失。然后，我们应用隐马尔可夫模型来得到一个更平滑的音高轨迹。我们的算法即保留了 YIN 的高精度，又能达到一个更高的召回率和精确率。

## 4. 方法
本章描述了我们提出的 PYIN 算法，它分为两个阶段：（1）逐帧抽取多个与概率相关的音高候选值，（2）使用 HMM 得到更平滑的音高轨迹。接下来将依次介绍这两个阶段。

### 4.1. 候选值
PYIN 的第一个阶段与原始的 YIN 算法的步骤类似，不同之处仅在于阈值这个阶段，前者假设了一个阈值分布，而后者依赖于单个阈值（见图 1）。

{% include figure.liquid path="/assets/img/paper_pyin/图1.png" class="img-fluid rounded" %}

YIN 算法基于以下理论，在信号 $x_i, \, i=1,\cdots, 2W,$ 中，如果信号近似以 $\tau=1/f_0$ 为基本周期，那么差分
$$
\begin{align}
d_t(\tau) = \sum_{j=1}^{W}(x_j-x_{j+\tau})^2, \tag{1}
\end{align}
$$

的值将会很小。该差分的值可以通过计算自相关函数（ACF）来得到
$$
\begin{align}
r_t(\tau) = \sum_{j={t+1}}^{t+W} x_j x_{j+\tau}, \tag{2}
\end{align}
$$

$(1)$ 可以用下式来计算
$$
\begin{align}
d_t(\tau) = r_t(0) + r_{t+\tau}(0) - 2r_t(\tau). \tag{3}
\end{align}
$$

上述两个计算包含了原始 YIN 算法的前两个步骤，如图 1 所示。原始 YIN 算法的第三步是对 $(1)$ 中的差分进行归一化，来得到累积均值归一化差分函数 $d^{'}(\tau)$（为了方便说明，忽略下标 $t$）。

原始 YIN 算法的第四步是从差分函数 $d^{'}$ 中找到与基本周期对应的凹陷。具体做法是，找到使得 $d^{'}$ 取局部最小值并且 $d^{'}(\tau) < s$ 的最小的 $\tau$，其中 $s$ 是固定阈值（通常 $s=0.1$ 或 $s=0.15$）。如果所有的 $d^{'}(\tau)>s$，那么原始的 YIN 论文将 $\argmin_{\tau}d^{'}(\tau)$ 作为周期估计；或者可以认为不存在音高。我们将 YIN 估计的周期表示为 $Y(x_t,s)$。

{% include figure.liquid path="/assets/img/paper_pyin/图2.png" class="img-fluid rounded" %}

因为阈值的选择以及当所有的值都大于阈值时所采用的策略会影响最终的结果。所以，我们放弃使用单阈值，并提出使用一个由 $P(s_i)$ 给出的先验参数分布 $S$，其中 $s_i, \, i=1,\cdots,N$ 是可选阈值。我们选择的阈值范围从 $0.01$ 到 $1$，且步长为 $0.01$，也就是说 $N=100$。我们实验中使用的分布是均值为 $0.1, \, 0.15, \, 0.2（\alpha=1 \, \text{且} \, \beta=18, \, 11\frac{1}{3}, \, 8）$ 的 Beta 分布，如图 2 所示。给定这样的分布，以及使用绝对最小值策略的先验概率 $p_a$，我们就能根据 YIN 来定义周期 $\tau$ 是基本周期 $\tau_0$ 的概率
$$
\begin{align}
P(\tau=\tau_0|S,x_t) = \sum_{i=1}^{N}a(s_i,\tau)P(s_i)[Y(x_t,s_i)=\tau], \tag{4}
\end{align}
$$

其中 $[\cdot]$ 是 the Iverson bracket，如果表达式为真，其返回值为 $1$；否则，返回值为 $0$。
$$
a(s_i,\tau) = 
\begin{cases}
1, & \text{if} \; d^{'}(\tau) < s_i \\
p_a, & \text{otherwise.} \tag{5}
\end{cases}
$$

我们使用 $p_a=0.01$。注意到如果 $p_a<1$，那么 $(4)$ 的和就不一定是 $1$。$1-(4)$ 式的结果可以解释为该帧是非语音的概率。

任何使得 $P(\tau=\tau_0|S,x_t) > 0$ 的 $\tau$ 都会生成一个基频候选值 $f=1/\tau$。与原始 YIN 算法一样，PYIN 也对差分函数 $d^{'}$ 进行抛物线插值来提升频率估计。

基频候选值的集合与其对应的概率一起作为 PYIN 算法第一阶段的输出。它有着以下几个吸引人的属性：
* 任何位于差分函数 $d^{'}$ 局部最小值处且使得 $(4)$ 为非零值的 $\tau$ 都是某个阈值 $s$ 所对应的真实的 YIN 频率估计。
* 可以在原始 YIN 算法的基础上以最小的计算代价得到概率估计。
* 传统的 YIN 估计位于这些候选值之中，也就是说 PYIN 至少包含了与 YIN 一样多的真实基频估计。

最后一点是我们方法的主要动机，在原始 YIN 算法中，一旦估计值是错误的，真实值将不会被恢复。我们的改进是基于我们观察到在很多情况下，存在一个未知的阈值，能使得 YIN 输出正确的音高，如表 1 所示：PYIN 的候选值集合相比 YIN 的任何参数都具有更高的音高召回率。稍后我们将会证明，这大大提高了 PYIN 的第二阶段中音高追踪的有效性。

{% include figure.liquid path="/assets/img/paper_pyin/表1.png" class="img-fluid rounded" %}

### 4.2. 音高追踪
音高追踪步骤在每一帧上至多选出一个合适的音高候选值。我们将音高范围划分成 $M=480$ 个频点，横跨了四个八度从 $55\text{Hz（A1）}$ 到 $880\text{Hz（A5）}$，步长为 $10$ 个音分（$0.1$ 个半音）。

这些音高频点可以被建模为隐马尔可夫模型（HMM）中的状态。模型将直接把在 PYIN 第一阶段中计算得到的音高候选值的概率作为观测概率：每个观测到的音高候选值的概率将被分配给最接近其估计频率的频点；这将会产生一个稀疏的观测向量 $p_m^{*}, \, m=1,\cdots,M$，只有其中的非零元素是最接近音高候选值的。我们使用该思路，并且在一个已有的音符追踪方法的启发下，开发出了一个更实用的 HMM，其中每个音高对应语音（$v=1$）和非语音（$v=0$）状态（也就是有 $2M$ 个音高状态）。假设处于语音或非语音状态的先验概率是 $P(v=1) = P(v=0) = 0.5$，我们将我们模型的观测概率定义为
$$
p_{m,v} = 
\begin{cases}
0.5 \; \cdot \; p_m^{*}, & \text{for} \; v=1 \\
0.5 \; \cdot \; (1-\sum_k P_k^{*}) & \text{for} \; v = 0.\tag{6}
\end{cases}
$$

模型的转移概率有两个主要目的：偏好更平滑的音高轨迹，以及偏好语音和非语音之间较少的变化。我们将此编码为与发音过渡和音高过渡相关的两个分布：
$$
\begin{align}
p_v &= P(v_t|v_{t-1}) \notag \\
    &=
  \begin{cases} 
    0.99, & \text{if no change} \\
    0.01, & \text{otherwise, and} \tag{7}
  \end{cases} \\
p_{ij} &= P(\text{pitch}_t = j | \text{pitch}_{t-1} = i) \tag{8}
\end{align}
$$

后者被实现为三角形权重分布，它让音高最多跳跃 $25$ 个频点，对应于相邻两帧之间最多差 $2.5$ 个半音。最高的似然峰值位于 $0$ 半音处。对三角窗始终进行归一化，使得其和为 $1$。更多的信息可以参考源码。假设 $(7)$ 和 $(8)$ 所描述的两个状态是独立的，那么，这两个状态之间的实际转移概率就是两个独立概率的乘积。初始概率被设置为在非语音状态上的均匀分布，并且使用高效版本的维特比算法（利用转移矩阵的稀疏性）对 HMM 进行解码。

## 5. 结果
我们基于 RWC 音乐数据库提供的 F0 音高轨迹合成歌唱音频，并将其保存为采样率等于 44.1kHz 的线性 PCM wav 文件。这些曲目涵盖了数据库中流行音乐部分的 100 首完整歌曲。为了模拟更真实的情况，除了这些原始 wav 文件之外，我们还使用 Audio Degradation Toolbox 中的五个预设来降低音频的质量。最终，整个数据集包含了超过 30 个小时的音频数据。后续所有的结果均基于此数据集。

我们实验了三个不同 Beta 参数分布（均值分别为 $0.10, \, 0.15, \, 0.20$，见图 2）下的 PYIN 算法。作为对比，我们还对参数分布 $S$ 另取了三个不同的版本，该分布下只有一个非零元素 $s_i$（同样也是 $0.10，\, 0.15, \, 0.20$）。由于这实际上简化为原始的 YIN 算法加平滑处理，我们将其表示为 YIN+S。基线是有着三个不同阈值参数 $s=0.10, \, 0.15, \, 0.20$ 的原始 YIN 算法。所有方法都在  Vamp 插件的实现中运行，其步长为 $256（5.8\text{ms}）$，帧长为 $2048（46.4\text{ms}）$。

### 5.1. 对合成数据的定量分析
**Recall.** 我们希望有较高的召回率。如果估计值在真实频率的一个半音以内，我们就认为正确地检测到了音高。

{% include figure.liquid path="/assets/img/paper_pyin/图3.png" class="img-fluid rounded" %}

图 3a 的结果表明任意 beta 分布下的 PYIN（$.10, \, .15, \, .20$） 估计明显优于 YIN 的估计值。与任何传统的 YIN 算法（中值均低于 $0.951$）相比，PYIN 算法的召回率中值（$0.977，
\, 0.982，\, 0.984$）更接近全部候选值覆盖的正确音高数量给出的上限（$0.98$）。

注意到 YIN+S 的召回率要比原始 YIN 算法的召回率差。这是因为每帧音频只有一个 YIN 估计值用于平滑，因此召回率收到 YIN 算法能力的限制。

**Precision and F Score.** 除了召回率还需要高精确率。如图 3b 所示，所有的 PYIN 和 YIN+S 都要优于原始的 YIN 算法。注意到 YIN+S 的精确率最高，因为它可以将较少的帧识别为浊音。图 3c 给出了一个权衡了召回率和精确率的综合指标—$F$ score 的结果，$F=2\frac{\text{precision} \times \text{recall}}{\text{precision+recall}}$，可以看到 PYIN 算法取得了最优结果。

**Octave Errors and Voicing Detection.** PYIN 算法针对 octave errors 具有很好的鲁棒性（分别是 $0.5\%, \, 0.9\%$ 和 $1.7\%$），很好的发声检测召回率（分别是 $92.5\%, \, 94.1\%$ 和 $95.0\%$）和 specificity（分别是 $91.9\%, \, 90.6\%$ 和 $88.9\%$）。

{% include figure.liquid path="/assets/img/paper_pyin/图4.png" class="img-fluid rounded" %}

### 5.2. 真实的人声歌唱
图 4 给出了由 YIN .15 和 PYIN .15 提取的歌曲 "Happy Birthday" 的最后四个音符的音高轨迹。该录音由一位女歌手演唱，用于音调研究。虽然两个算法几乎完美地估计出了前两个音符（到 $59$ 秒）的音高，但 YIN 算法在后半部分出现较多的 octave errors。这可能是由歌手不寻常的呼吸音色造成的。PYIN 更鲁棒正确估计出了音高。


## 6. 结论
我们提出了 PYIN 算法，它是 YIN 算法的一种改进，它基于 YIN 的概率解释联合考虑了多个音高候选值。YIN 阈值参数的先验分布生成了一组与概率相关的音高候选值，这些候选值也由 YIN 计算得到。将这些候选概率作为 HMM 中的观测概率，并使用维特比算法对其进行解码，就可以得到时间上更平滑的音高轨迹。我们证明了在超过 $30$ 小时的合成歌唱音频上，PYIN 的召回率和精确率都要高于 YIN。由于 PYIN 对 YIN的阈值分布进行了参数化，因此，它对分布选择的鲁棒性比 YIN 对阈值选择的鲁棒性更强。