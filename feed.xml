<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://xinleiren.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://xinleiren.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-20T07:03:02+00:00</updated><id>https://xinleiren.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">文章列表</title><link href="https://xinleiren.github.io/blog/2024/blog-list/" rel="alternate" type="text/html" title="文章列表"/><published>2024-12-19T00:00:00+00:00</published><updated>2024-12-19T00:00:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/blog-list</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/blog-list/"><![CDATA[<h2 id="论文笔记">论文笔记</h2> <p>123</p> <h3 id="音频大模型">音频大模型</h3> <p>123</p> <h3 id="音频信号处理">音频信号处理</h3> <p>123</p> <h3 id="语音增强分离">语音增强/分离</h3> <p>123</p> <hr/> <h2 id="书籍笔记">书籍笔记</h2> <p>123</p> <h3 id="digital-audio-effects2nd-ed">Digital Audio Effects(2nd ed.)</h3> <p>123</p> <h3 id="digital-audio-resampling">Digital Audio Resampling</h3> <p>123</p> <h3 id="speech-and-language-processing3rd-ed-draft">Speech and Language Processing(3rd ed. draft)</h3> <p>123</p> <h3 id="the-scientist-and-engineers-guide-to-digital-signal-processing">The Scientist and Engineer’s Guide to Digital Signal Processing</h3> <hr/> <h2 id="个人理解">个人理解</h2> <p>123</p> <h3 id="神经网络">神经网络</h3> <p>123</p> <h3 id="音频信号处理-1">音频信号处理</h3> <p>123</p>]]></content><author><name></name></author><category term="blog-list"/><category term="音频信号处理"/><category term="语音增强"/><category term="神经网络"/><category term="音频大模型"/><summary type="html"><![CDATA[请读者先阅读该文章列表，以了解整个博客内容]]></summary></entry><entry><title type="html">谈谈音频信号处理中 CNN 的因果性</title><link href="https://xinleiren.github.io/blog/2024/causal-cnn/" rel="alternate" type="text/html" title="谈谈音频信号处理中 CNN 的因果性"/><published>2024-12-18T00:00:00+00:00</published><updated>2024-12-18T00:00:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/causal-cnn</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/causal-cnn/"><![CDATA[<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="gh"># &lt;font face="Times New Roman"&gt;1.&lt;/font&gt; 引言</span>
音频信号处理已经进入了神经网络时代，而 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 由于其强大的建模能力，已被广泛地应用在了各种音频信号处理网络中，像最近几届 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>DNS Challenge<span class="nt">&lt;/font&gt;</span> 的冠军所提出的网络均大量使用了 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span>。与图像处理不同，音频信号处理在大多数应用场景下都需要满足实时性要求，比如在线会议场景，直播场景等。满足实时性一般需要满足以下两个条件：<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>算法是因果的<span class="nt">&lt;/font&gt;</span>且<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>计算复杂度要低<span class="nt">&lt;/font&gt;</span>。本文主要讨论如何控制 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络的因果性，并不对其计算复杂度做过多讨论。

从网络架构来说，以 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 为主的音频信号处理网络可以分为以下两大类：
<span class="p">*</span> 只包含卷积的 <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 架构<span class="nt">&lt;/font&gt;</span>
<span class="p">*</span> 即包含卷积又包含转置卷积的 <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder-Decoder<span class="nt">&lt;/font&gt;</span> 架构<span class="nt">&lt;/font&gt;</span>

本文对上述两种网络架构均进行了讨论，并进一步讨论了在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 过程中应该怎么做以及可能遇到的一些问题。

<span class="gh"># &lt;font face="Times New Roman"&gt;2.&lt;/font&gt; 因果性</span>
在讨论之前，先简单介绍下系统的因果性。因果性是指：<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>当一个系统当前时刻的输出只依赖于当前时刻的输入以及（或）过去时刻的输入时，该系统就是因果的。<span class="nt">&lt;/font&gt;</span>与之相对应的，<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>当一个系统当前时刻的输出会依赖未来时刻的输入时，该系统就是非因果的。<span class="nt">&lt;/font&gt;</span> 

可见，在实时应用中，音频信号处理算法往往需要是因果的，以对当前时刻的输入信号作出及时的响应。

<span class="gh"># &lt;font face="Times New Roman"&gt;3. Encoder&lt;/font&gt; 架构</span>
<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 架构主要由卷积网络构成， 该节先从最简单的一层卷积网络开始讨论，接着拓展到多层卷积网络的情况。

<span class="gu">## &lt;font face="Times New Roman"&gt;3.1.&lt;/font&gt; 一层卷积网络</span>
考虑一个只包含了一层二维卷积的网络，该二维卷积在时间维度上的参数为：<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 3，stride = 1<span class="nt">&lt;/font&gt;</span>。

<span class="gu">### &lt;font face="Times New Roman"&gt;3.1.1.&lt;/font&gt; 网络的输入，输出以及 &lt;font face="Times New Roman"&gt;label&lt;/font&gt;</span>
假设此时输入给网络一个时长为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧的音频信号，那么输出信号的时长应该为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5 - kernel + 1 = 5 - 3 + 1 = 3<span class="nt">&lt;/font&gt;</span> 帧，网络的输出比输入少了 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧（这 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧作为音频信号的上下文信息被网络消耗掉了）。那么问题来了：输出信号只有 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧，但 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号和输入信号一样都是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧，输出信号的时长不等于 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号的时长，该怎么计算 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>loss<span class="nt">&lt;/font&gt;</span> 函数那？

<span class="gu">### &lt;font face="Times New Roman"&gt;3.1.2.&lt;/font&gt; 决定网络的因果性</span>
一个自然而然的想法就是：<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>从 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中选取 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧信号，保证 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号和输出信号的时长一样不就得了？没错，确实是这样做，而且正是该选取过程决定了卷积网络的因果性。<span class="nt">&lt;/font&gt;</span>

以目前所讨论的这个网络来说，有 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 种选取方案，如图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 所示。<span class="sb">





</span>&lt;figure
<span class="gt">  
&gt;</span>
  <span class="nt">&lt;picture&gt;</span>
    <span class="c">&lt;!-- Auto scaling with imagemagick --&gt;</span>
    &lt;!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    --&gt;
    
      &lt;source
        class="responsive-img-srcset"
        
          srcset="/assets/img/causal_cnn/%E5%9B%BE1-480.webp 480w,/assets/img/causal_cnn/%E5%9B%BE1-800.webp 800w,/assets/img/causal_cnn/%E5%9B%BE1-1400.webp 1400w,"
          type="image/webp"
        
        
          sizes="95vw"
<span class="gt">        
      &gt;</span>
    
    &lt;img
      src="/assets/img/causal_cnn/%E5%9B%BE1.jpg"
      
        class="img-fluid rounded"
      
      
        width="100%"
      
      
        height="auto"
      
      
      
      
      
      
        loading="lazy"
      
      onerror="this.onerror=null; $('.responsive-img-srcset').remove();"
<span class="gt">    &gt;</span>
  <span class="nt">&lt;/picture&gt;</span>

  
<span class="nt">&lt;/figure&gt;</span>
<span class="nt">&lt;center&gt;</span>图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span>. 一层卷积网络因果性示例<span class="nt">&lt;/center&gt;</span>

<span class="ni">&amp;emsp;&amp;emsp;</span>
<span class="p">*</span> 图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(a)<span class="nt">&lt;/font&gt;</span> 选取 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中的最后 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧，这种选取方式确定了该网络是因果的。因为从图中可以看出当前时刻的输出帧只利用了当前时刻的输入帧以及历史的两帧信息；
<span class="p">*</span> 图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(b)<span class="nt">&lt;/font&gt;</span> 选取 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中最中间的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧，这种选取方式确定了该网络是非因果的。因为从图中可以看出当前时刻的输出帧除了利用当前时刻的输入帧以及历史的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 帧信息外，还使用了未来的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 帧信息；
<span class="p">*</span> 图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(c)<span class="nt">&lt;/font&gt;</span> 选取 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中最前面的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧，这种选取方式确定了该网络是非因果的。因为从图中可以看出当前时刻的输出帧除了利用当前时刻的输入帧外，还使用了未来的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧信息；

<span class="gu">### &lt;font face="Times New Roman"&gt;3.1.3.&lt;/font&gt; 补零操作</span>
通过上述分析，相信读者已经熟悉该如何决定卷积网络的因果性，以及如何控制卷积网络的感受野。那么在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 的过程中，当拥有了输入数据和等时长的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 数据之后，该怎么做，才能实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 所示的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 种方式那？主要有以下两种方法：
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>丢 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 中的数据；<span class="nt">&lt;/font&gt;</span>
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>给输入数据补零。<span class="nt">&lt;/font&gt;</span>

<span class="gs">**丢 &lt;font face="Times New Roman"&gt;label&lt;/font&gt; 中的数据**</span>：这种实现方式其实就是直接根据 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3.1.2.<span class="nt">&lt;/font&gt;</span> 小节所分析的来做的。丢弃 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中的前两帧信号得到的就是图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(a)<span class="nt">&lt;/font&gt;</span> 所表示的；丢弃 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中的第一帧和最后一帧信号得到的就是图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(b)<span class="nt">&lt;/font&gt;</span> 所表示的；丢弃 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中的最后两帧信号得到的就是图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(c)<span class="nt">&lt;/font&gt;</span> 所表示的；

<span class="gs">**给输入数据补零**</span>：那么可不可以保持 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 数据不变，通过其他方法来实现那？当然可以！正所谓 <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>“山不过来，我就过去”<span class="nt">&lt;/font&gt;</span>，既然要求 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 数据不变，那就变输入数据，给输入数据补零。相信读者在一些论文或者开源代码中也见过补零这种实现方式。补零相比上述实现方式有什么好处那？笔者考虑了一下，主要想出了以下两点说得过去的原因：
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>为了不浪费数据。<span class="nt">&lt;/font&gt;</span>从上述分析可以看到，当卷积网络在时间维度上的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel<span class="nt">&lt;/font&gt;</span> 大于 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 时，网络的输出时长会比输入时长少 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel - 1<span class="nt">&lt;/font&gt;</span> 帧。而 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel<span class="nt">&lt;/font&gt;</span> 越大，网络的输出时长就越小。为了能将辛辛苦苦生成的训练数据全部用上，可以给输入信号补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel - 1<span class="nt">&lt;/font&gt;</span> 帧的零，这样就能使得网络的输出时长等于输入时长（有效的输入时长，即补零之前的时长）；
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>为了和实时推理代码保持一致。<span class="nt">&lt;/font&gt;</span> 考虑一个实时应用会遇到的一个场景：假设某个音频处理算法运行在时频域（其 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>STFT<span class="nt">&lt;/font&gt;</span> 的窗长和帧长均为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>20ms<span class="nt">&lt;/font&gt;</span>，帧移为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>10ms<span class="nt">&lt;/font&gt;</span>），当算法接收到第一帧 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>10ms<span class="nt">&lt;/font&gt;</span> 信号的时候，为了做 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>STFT<span class="nt">&lt;/font&gt;</span>，往往需要在前面补一帧 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>10ms<span class="nt">&lt;/font&gt;</span> 的零，凑足 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>20ms<span class="nt">&lt;/font&gt;</span>。在因果卷积网络中补零的原因之一也是为了和这种场景保持一致。

<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>不同的补零方式会导致不同的因果关系，<span class="nt">&lt;/font&gt;</span>下面就详细说说，具体该怎么补零（读者可自行画图分析）：
<span class="p">*</span> 为了实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(a)<span class="nt">&lt;/font&gt;</span>，可以在输入数据的最前面补两帧零；
<span class="p">*</span> 为了实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(b)<span class="nt">&lt;/font&gt;</span>，可以在输入数据的最前面和最后面各补一帧零；
<span class="p">*</span> 为了实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1(c)<span class="nt">&lt;/font&gt;</span>，可以在输入数据的最后面补两帧零。

<span class="gu">### &lt;font face="Times New Roman"&gt;3.1.4.&lt;/font&gt; 总结</span>
从对一层卷积网络的分析过程来看，可以得到以下两个重要结论：
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>从 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号中选取所需信号的过程决定了卷积网络的因果性和感受野；<span class="nt">&lt;/font&gt;</span>
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>在具体 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 的过程中，可以通过给输入数据补零来实现不同的因果关系<span class="nt">&lt;/font&gt;</span>。

<span class="gu">## &lt;font face="Times New Roman"&gt;3.2.&lt;/font&gt; 多层卷积网络</span>
本节考虑包含了两层二维卷积的网络，且每层二维卷积在时间维度上的参数均为：<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 3，stride = 1<span class="nt">&lt;/font&gt;</span>。类似于图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span>，现给出相应的两层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络的因果性示例图，如图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 所示。<span class="sb">





</span>&lt;figure
<span class="gt">  
&gt;</span>
  <span class="nt">&lt;picture&gt;</span>
    <span class="c">&lt;!-- Auto scaling with imagemagick --&gt;</span>
    &lt;!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    --&gt;
    
      &lt;source
        class="responsive-img-srcset"
        
          srcset="/assets/img/causal_cnn/%E5%9B%BE2-480.webp 480w,/assets/img/causal_cnn/%E5%9B%BE2-800.webp 800w,/assets/img/causal_cnn/%E5%9B%BE2-1400.webp 1400w,"
          type="image/webp"
        
        
          sizes="95vw"
<span class="gt">        
      &gt;</span>
    
    &lt;img
      src="/assets/img/causal_cnn/%E5%9B%BE2.jpg"
      
        class="img-fluid rounded"
      
      
        width="100%"
      
      
        height="auto"
      
      
      
      
      
      
        loading="lazy"
      
      onerror="this.onerror=null; $('.responsive-img-srcset').remove();"
<span class="gt">    &gt;</span>
  <span class="nt">&lt;/picture&gt;</span>

  
<span class="nt">&lt;/figure&gt;</span>
<span class="nt">&lt;center&gt;</span>图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span>. 二层卷积网络因果性示例<span class="nt">&lt;/center&gt;</span>

<span class="ni">&amp;emsp;&amp;emsp;</span>
需要注意的是，图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 只给出了其中的三种输出结果，还有其余两种输出结果读者可自行分析。通过图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 可以看出：
<span class="p">*</span> 图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(a)<span class="nt">&lt;/font&gt;</span> 表示的是非因果网络，因为输出帧除了利用当前时刻的输入帧外，还使用了未来的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>4<span class="nt">&lt;/font&gt;</span> 帧信息；
<span class="p">*</span> 图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(b)<span class="nt">&lt;/font&gt;</span> 表示的是非因果网络，因为输出帧除了利用当前时刻的输入帧以及历史的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧信息外，还使用了未来的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧信息；
<span class="p">*</span> 图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(c)<span class="nt">&lt;/font&gt;</span> 表示的是因果网络，因为输出帧只利用了当前时刻的输入帧以及历史的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>4<span class="nt">&lt;/font&gt;</span> 帧信息。

与 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3.1.<span class="nt">&lt;/font&gt;</span> 节的分析过程一样，在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 过程中，该如何补零才能使得两层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 中所示的因果性那？对于两层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络来说，笔者能想到两种补零方式：<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>输入层补零<span class="nt">&lt;/font&gt;</span>和<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>逐层补零<span class="nt">&lt;/font&gt;</span>。下面就详细讨论下这两种方式，以及各自的优缺点。

<span class="gu">### &lt;font face="Times New Roman"&gt;3.2.1.&lt;/font&gt; 输入层补零</span>
<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>输入层补零其实就是把两层卷积网络等效于一层卷积网络。<span class="nt">&lt;/font&gt;</span>上述两层卷积网络可以等效于 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 5，stride = 1<span class="nt">&lt;/font&gt;</span> 的一层卷积网络（只是从因果性和感受野角度来说是可以等效的）。从 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3.1.3.<span class="nt">&lt;/font&gt;</span> 小节的分析可知：
<span class="p">*</span> 给输入数据的最后面补四帧零，可以实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(a)<span class="nt">&lt;/font&gt;</span>；
<span class="p">*</span> 给输入数据的最前面和最后面各补两帧零，可以实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(b)<span class="nt">&lt;/font&gt;</span>；
<span class="p">*</span> 给输入数据的最前面补四帧零，可以实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(c)<span class="nt">&lt;/font&gt;</span>。

也就是说<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>输入层补零只在输入数据上补零<span class="nt">&lt;/font&gt;</span>，网络隐藏层不需要补零；下面要讨论的<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>逐层补零除了在输入层补零外也在网络隐藏层补零。<span class="nt">&lt;/font&gt;</span>

<span class="gu">### &lt;font face="Times New Roman"&gt;3.2.2.&lt;/font&gt; 逐层补零</span>
具体来说，逐层补零在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 的过程中：
<span class="p">*</span> 为了实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(a)<span class="nt">&lt;/font&gt;</span>，可以在输入层和隐藏层的最后面分别补两帧零；
<span class="p">*</span> 为了实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(b)<span class="nt">&lt;/font&gt;</span>，可以在输入层和隐藏层的最前面和最后面分别补一帧零；
<span class="p">*</span> 为了实现图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(c)<span class="nt">&lt;/font&gt;</span>，可以在输入层和隐藏层的最前面分别补两帧零。

<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>逐层补零只考虑当前层<span class="nt">&lt;/font&gt;</span>。以图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2(a)<span class="nt">&lt;/font&gt;</span> 为例，输入层为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧数据，为了使第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的输出也为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧数据，并且保持只看当前帧和未来帧的因果性，需要给输入层的最后面补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel - 1 = 3 - 1 = 2<span class="nt">&lt;/font&gt;</span> 帧零。同样，为了使第二层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的输出也为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧数据，并且保持只看当前帧和未来帧的因果性，需要给第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 输出（隐藏层）的最后面补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span> kernel - 1 = 3 - 1 = 2<span class="nt">&lt;/font&gt;</span> 帧零。可以看出逐层补零保证每层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的输出时长都和 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号的时长保持一致。

<span class="gu">### &lt;font face="Times New Roman"&gt;3.2.3.&lt;/font&gt; 两种补零方式对比</span>
两种不同的补零方式可以说体现出了两种不同的思维方式。
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>输入层补零<span class="nt">&lt;/font&gt;</span>：将多层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络当成一个整体看待。先分析这个整体总共需要补多少零，需要怎么补，然后直接只在输入层操作就行；
<span class="p">*</span> <span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>逐层补零<span class="nt">&lt;/font&gt;</span>：将多层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络中的每一层当成单独的个体看待。根据当前层的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel<span class="nt">&lt;/font&gt;</span> 和 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>stride<span class="nt">&lt;/font&gt;</span> 求出当前层需要补多少零，根据整个网络要满足的因果性和感受野确定当前层的零该怎么补，然后在当前层直接操作就行。 逐层补零能保证每层的输出时长和输入时长（有效的输入时长，即补零之前的时长）一致，继而保证整个网络的输出时长和输入时长一致。当前层只需要干好它自己要干的事就好，不必考虑其他层。层与层之间的关系可以用一句古语来概括 “各人自扫门前雪，莫管他人瓦上霜”。

下面再举个额外的例子，用以说明在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 过程中两种补零方式分别该怎么做。比如开发者要搭建一个两层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络，且第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的参数配置为：<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 3，stride = 1<span class="nt">&lt;/font&gt;</span>，第二层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的参数配置为：<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 2，stride = 1<span class="nt">&lt;/font&gt;</span>。现在想要使这个网络的输出帧只能看未来一帧的输入信息。

 <span class="gs">**输入层补零的做法**</span>
这个两层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络可以等效为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 4，stride = 1<span class="nt">&lt;/font&gt;</span> 的一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 网络。因此，需要给输入数据补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel - 1 = 4 - 1 = 3<span class="nt">&lt;/font&gt;</span> 帧零。为了只看未来一帧的输入信息，需要将 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧零补在输入数据的最前面，<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 帧零补在输入数据的最后面。

 <span class="gs">**逐层补零的做法**</span>
可知输入层需要补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3 - 1 = 2<span class="nt">&lt;/font&gt;</span> 帧零，第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的输出需要补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2 - 1 = 1<span class="nt">&lt;/font&gt;</span> 帧零。接下来就是确定每层的零具体该怎么补。为了只看未来一帧的输入信息，可以有以下两种补零方案：
<span class="p">*</span> 输入层需要补的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧零全补在最前面，且第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的输出需要补的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 帧零补在最后面；这种方式使得第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 没利用未来的输入信息，而第二层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 利用了未来一帧的输入信息。
<span class="p">*</span> 输入层需要补的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧零在最前面和最后面各补 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 帧，且第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的输出需要补的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/font&gt;</span> 帧零补在最前面；这种方式使得第一层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 利用了未来一帧的输入信息，第二层 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 没有利用未来的输入信息。

可以看到，在具体 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 的时候，输入层补零这种方式实现方法唯一，而逐层补零这种方式有多种实现方法。

<span class="gu">### &lt;font face="Times New Roman"&gt;3.2.4.&lt;/font&gt; 逐层补零需要注意的地方</span>
假设一个这样的使用场景：<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1）<span class="nt">&lt;/font&gt;</span>模型是按照逐层补零的方式实现的因果模型；<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2）<span class="nt">&lt;/font&gt;</span>在验证模型效果的时候（即推理的时候）直接使用 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>load()<span class="nt">&lt;/font&gt;</span> 函数加载模型，而且按照线上运行的方式那样，每次给模型输入一帧数据，然后模型输出一帧数据；这个时候得到的输出结果很大概率上是不正确的。这是因为在训练模型的时候，模型的输入数据时长往往远远大于所补零的时长，除了输入数据中比较靠前的数据看到的历史信息是补的零之外，其余输入数据看到的历史信息基本都是有效的语音信息。而在推理过程中，每次只输入一帧数据，这导致输入的所有帧看到的历史信息都是补的零，而不是有效的语音信息。因此，输出结果大概率是不正确的。为了避免这种状况，<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>1）<span class="nt">&lt;/font&gt;</span>只是为了验证模型效果的话，在推理的时候，可以增加模型的输入数据时长，而不是输入一帧数据；<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2）<span class="nt">&lt;/font&gt;</span>如果非要按照线上运行的方式那样，输入一帧数据输出一帧数据，那么就需要用 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>c/python<span class="nt">&lt;/font&gt;</span> 实现推理过程，与此同时需要维护好每层网络的输入 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>buffer<span class="nt">&lt;/font&gt;</span>。这是一项工作量较大的工程。
同样的场景，输入层补零的方式解决起来相对简单些，只需维护好输入层的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>buffer<span class="nt">&lt;/font&gt;</span> 就行。

<span class="gu">### &lt;font face="Times New Roman"&gt;3.2.5.&lt;/font&gt; 总结</span>
本节以二层卷积网络为例，分析了多层网络如何通过补零来实现不同的因果性。在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 过程中主要有<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>输入层补零<span class="nt">&lt;/font&gt;</span>和<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>逐层补零<span class="nt">&lt;/font&gt;</span>两种方式，可根据需要选择适合的补零方式。

<span class="gu">## &lt;font face="Times New Roman"&gt;3.3.&lt;/font&gt; 总结</span>
对于 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 架构而言，通过上述的分析可知，不管是一层卷积网络还是多层卷积网络，不管是输入层补零还是逐层补零，如果想要实现的网络是因果的，那么零应该全部补在最前面，如果想要实现的网络是非因果的，那么应该在最后面补零。在最前面补了几帧零，整个网络就使用了多少帧的历史信息。同理，在最后面补了几帧零，整个网络就使用了多少帧的未来信息。

<span class="gh"># &lt;font face="Times New Roman"&gt;4. Encoder-Decoder&lt;/font&gt; 架构</span>
<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder-Decoder<span class="nt">&lt;/font&gt;</span> 是一种对称的网络结构。其中，<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 包含的是卷积网络，<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Decoder<span class="nt">&lt;/font&gt;</span> 包含的是转置（或称之为反转/逆）卷积网络。而且一般 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Decoder<span class="nt">&lt;/font&gt;</span> 中每个转置卷积网络层和与之对应的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 中的卷积网络层的参数配置（<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel，stride……<span class="nt">&lt;/font&gt;</span>）是完全一样的。本节先简单回顾下转置卷积，然后分析一层卷积（转置卷积）网络的因果性，最后分析多层卷积（转置卷积）网络的因果性。

<span class="gu">## &lt;font face="Times New Roman"&gt;4.1.&lt;/font&gt; 转置卷积</span>
与卷积相反，转置卷积会增加输入特征的维度。本节以 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 3，stride = 1<span class="nt">&lt;/font&gt;</span> 的一层转置卷积网络为例进行说明。

当给同等参数配置下的一层卷积网络输入 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧的音频信号时，它会输出 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧的音频信号。而如果将这 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧音频信号输入给一层转置卷积网络，那么将会输出 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧音频信号。图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 展示了该转置卷积网络的计算过程。<span class="sb">





</span>&lt;figure
<span class="gt">  
&gt;</span>
  <span class="nt">&lt;picture&gt;</span>
    <span class="c">&lt;!-- Auto scaling with imagemagick --&gt;</span>
    &lt;!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    --&gt;
    
      &lt;source
        class="responsive-img-srcset"
        
          srcset="/assets/img/causal_cnn/%E5%9B%BE3-480.webp 480w,/assets/img/causal_cnn/%E5%9B%BE3-800.webp 800w,/assets/img/causal_cnn/%E5%9B%BE3-1400.webp 1400w,"
          type="image/webp"
        
        
          sizes="95vw"
<span class="gt">        
      &gt;</span>
    
    &lt;img
      src="/assets/img/causal_cnn/%E5%9B%BE3.jpg"
      
        class="img-fluid rounded"
      
      
        width="100%"
      
      
        height="auto"
      
      
      
      
      
      
        loading="lazy"
      
      onerror="this.onerror=null; $('.responsive-img-srcset').remove();"
<span class="gt">    &gt;</span>
  <span class="nt">&lt;/picture&gt;</span>

  
<span class="nt">&lt;/figure&gt;</span>
<span class="nt">&lt;center&gt;</span>图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span>. 转置卷积网络计算过程示例<span class="nt">&lt;/center&gt;</span>

<span class="ni">&amp;emsp;&amp;emsp;</span>
由于 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 3<span class="nt">&lt;/font&gt;</span>，所以转置卷积网络每一帧输入所对应的输出都是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧，将对应位置上的所有帧的输出相加得到转置卷积网络的最终输出。比如输出中的第二帧等于第一帧输出的第二个元素与第二帧输出的第一个元素之和，如图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 中红圈所示。

<span class="gu">## &lt;font face="Times New Roman"&gt;4.2.&lt;/font&gt; 一层卷积（转置卷积）网络</span>
考虑一个 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>kernel = 3，stride = 1<span class="nt">&lt;/font&gt;</span> 的一层卷积（转置卷积）网络。假设网络的输入是时长为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧的音频信号，那么经过卷积网络之后，时长变为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧；接着，该 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧信号经过转置卷积网络之后，输出时长又变为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧，与输入信号和 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 信号的时长是相等的。因此，此时可以正常计算 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>loss<span class="nt">&lt;/font&gt;</span> 函数。注意在此过程中，是没有额外的补零或者其他什么操作的。那么，此时网络的因果性和感受野是怎么样的那？可以通过图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>4<span class="nt">&lt;/font&gt;</span> 分析一下整个计算过程。以输出的第 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3<span class="nt">&lt;/font&gt;</span> 帧为例，可以看出计算该帧的过程中，除了使用输入的当前帧和历史两帧信息外，还使用了未来两帧信息。其余输出帧所使用的输入帧信息可以通过图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>4<span class="nt">&lt;/font&gt;</span> 中的箭头走向分析得到。可以看到，此时网络是非因果网络，且使用了未来两帧的信息。<span class="sb">





</span>&lt;figure
<span class="gt">  
&gt;</span>
  <span class="nt">&lt;picture&gt;</span>
    <span class="c">&lt;!-- Auto scaling with imagemagick --&gt;</span>
    &lt;!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    --&gt;
    
      &lt;source
        class="responsive-img-srcset"
        
          srcset="/assets/img/causal_cnn/%E5%9B%BE4-480.webp 480w,/assets/img/causal_cnn/%E5%9B%BE4-800.webp 800w,/assets/img/causal_cnn/%E5%9B%BE4-1400.webp 1400w,"
          type="image/webp"
        
        
          sizes="95vw"
<span class="gt">        
      &gt;</span>
    
    &lt;img
      src="/assets/img/causal_cnn/%E5%9B%BE4.jpg"
      
        class="img-fluid rounded"
      
      
        width="100%"
      
      
        height="auto"
      
      
      
      
      
      
        loading="lazy"
      
      onerror="this.onerror=null; $('.responsive-img-srcset').remove();"
<span class="gt">    &gt;</span>
  <span class="nt">&lt;/picture&gt;</span>

  
<span class="nt">&lt;/figure&gt;</span>
<span class="nt">&lt;center&gt;</span>图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>4<span class="nt">&lt;/font&gt;</span>. 一层卷积网络和转置卷积网络计算过程示例<span class="nt">&lt;/center&gt;</span>

<span class="gu">### &lt;font face="Times New Roman"&gt;4.2.1.&lt;/font&gt;  控制网络的因果性和感受野</span>
那么，在具体 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 过程中，该怎么做才能得到一个因果网络，并且使得该网络输出的有效时长还是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧那？答案是<span class="nt">&lt;font</span> <span class="na">color=</span><span class="s">'red'</span><span class="nt">&gt;</span>输入数据补零，输出数据丢帧<span class="nt">&lt;/font&gt;</span>。图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 展示了该计算过程。<span class="sb">





</span>&lt;figure
<span class="gt">  
&gt;</span>
  <span class="nt">&lt;picture&gt;</span>
    <span class="c">&lt;!-- Auto scaling with imagemagick --&gt;</span>
    &lt;!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    --&gt;
    
      &lt;source
        class="responsive-img-srcset"
        
          srcset="/assets/img/causal_cnn/%E5%9B%BE5-480.webp 480w,/assets/img/causal_cnn/%E5%9B%BE5-800.webp 800w,/assets/img/causal_cnn/%E5%9B%BE5-1400.webp 1400w,"
          type="image/webp"
        
        
          sizes="95vw"
<span class="gt">        
      &gt;</span>
    
    &lt;img
      src="/assets/img/causal_cnn/%E5%9B%BE5.jpg"
      
        class="img-fluid rounded"
      
      
        width="100%"
      
      
        height="auto"
      
      
      
      
      
      
        loading="lazy"
      
      onerror="this.onerror=null; $('.responsive-img-srcset').remove();"
<span class="gt">    &gt;</span>
  <span class="nt">&lt;/picture&gt;</span>

  
<span class="nt">&lt;/figure&gt;</span>
<span class="nt">&lt;center&gt;</span>图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span>. 因果网络计算过程示例<span class="nt">&lt;/center&gt;</span>

<span class="ni">&amp;emsp;&amp;emsp;</span>
在输入数据的最前面补两帧零之后，网络的总体输入变为了 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>7<span class="nt">&lt;/font&gt;</span> 帧，经过卷积和转置卷积之后，网络的输出依然是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>7<span class="nt">&lt;/font&gt;</span> 帧。但是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>label<span class="nt">&lt;/font&gt;</span> 数据时长和补零前的输入数据时长一样，都是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 帧。此时，为了计算 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>loss<span class="nt">&lt;/font&gt;</span> 函数，需要从输出的 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>7<span class="nt">&lt;/font&gt;</span> 帧数据中丢弃 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/font&gt;</span> 帧数据。该丢弃过程在决定网络的因果性和感受野方面也起到了重要作用。

从图 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>5<span class="nt">&lt;/font&gt;</span> 中的箭头走向可以分析出，为了得到因果网络，只能丢弃输出数据中的最后两帧；同样可以分析出，为了得到非因果网络，且使用未来一帧的输入信息，只能丢弃输出数据中的第一帧和最后一帧；为了得到非因果网络，且使用未来两帧的输入信息，只能丢弃输出数据中最前面的两帧。

<span class="gu">### &lt;font face="Times New Roman"&gt;4.2.2.&lt;/font&gt; 总结</span>
本节介绍了如何通过给输入数据补零和丢弃输出数据来达到控制网络因果性和感受野的目的。本节给出的示例只是在输入数据的最前面补零，读者可按照同样的方法分析一下给输入数据最后面补零，或者最前面和最后面都补零会达到什么样的效果。

<span class="gu">## &lt;font face="Times New Roman"&gt;4.3.&lt;/font&gt; 多层卷积（转置卷积）网络 </span>
可使用 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3.2.<span class="nt">&lt;/font&gt;</span> 小节中的分析方法，对多层卷积（转置卷积）网络的因果性和感受野进行分析。即，可以把多层卷积（转置卷积）网络当成一个整体，只在输入数据和输出数据上做相应的补零或丢帧操作。也可以把网络中的每一层当成一个单独的个体，在每一层上做相应的操作，通过控制每一层的因果性和感受野来控制整个网络的因果性和感受野。具体分析过程，此处不在赘述。

如果想要使 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder-Decoder<span class="nt">&lt;/font&gt;</span> 架构的网络在实际推理的过程中输入一帧数据输出一帧数据，那么，同样也会遇到 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>3.2.4.<span class="nt">&lt;/font&gt;</span> 小节所提到的问题。不管训练的时候采用的是哪种补零（或者丢帧）方式，都需要动手实现网络的推理过程，并维护好每一层的输入输出 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>buffer<span class="nt">&lt;/font&gt;</span>。

<span class="gu">## &lt;font face="Times New Roman"&gt;4.4.&lt;/font&gt; 总结</span>
对于 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder-Decoder<span class="nt">&lt;/font&gt;</span> 架构的网络来说，为了控制网络的因果性和感受野，在实际 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 的过程中，可以通过给输入数据补零，并且丢弃输出数据中的帧来实现。

<span class="gh"># &lt;font face="Times New Roman"&gt;5.&lt;/font&gt; 后记</span>
前前后后历时一周，终于抽时间把这篇很久之前就想写的博客写完了。笔者是想到哪写到哪，有的点可能也没考虑到，如果读者感觉哪块写的不清楚或者有不同的意见和建议，欢迎提出，大家一起探讨。

“先把书读厚，再把书读薄”。再次感谢读者阅读到此处，和笔者一起经历了 “先把书读厚” 的过程。下面献上一张图片，大家一起 “再把书读薄”。<span class="sb">





</span>&lt;figure
<span class="gt">  
&gt;</span>
  <span class="nt">&lt;picture&gt;</span>
    <span class="c">&lt;!-- Auto scaling with imagemagick --&gt;</span>
    &lt;!--
      See https://www.debugbear.com/blog/responsive-images#w-descriptors-and-the-sizes-attribute and
      https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images for info on defining 'sizes' for responsive images
    --&gt;
    
      &lt;source
        class="responsive-img-srcset"
        
          srcset="/assets/img/causal_cnn/%E5%9B%BE6-480.webp 480w,/assets/img/causal_cnn/%E5%9B%BE6-800.webp 800w,/assets/img/causal_cnn/%E5%9B%BE6-1400.webp 1400w,"
          type="image/webp"
        
        
          sizes="95vw"
<span class="gt">        
      &gt;</span>
    
    &lt;img
      src="/assets/img/causal_cnn/%E5%9B%BE6.jpg"
      
        class="img-fluid rounded"
      
      
        width="100%"
      
      
        height="auto"
      
      
      
      
      
      
        loading="lazy"
      
      onerror="this.onerror=null; $('.responsive-img-srcset').remove();"
<span class="gt">    &gt;</span>
  <span class="nt">&lt;/picture&gt;</span>

  
<span class="nt">&lt;/figure&gt;</span><span class="sb">


</span>这幅图是 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Ke Tan，DeLiang Wang<span class="nt">&lt;/font&gt;</span> 的论文 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>"A Convolutional Recurrent Neural Network for Real-time speech enhancement"<span class="nt">&lt;/font&gt;</span> 中的图，笔者就是根据这幅图理解的因果卷积。从下往上看，这幅图可以理解为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 的计算过程，从上往下看，这幅图可以理解为 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Decoder<span class="nt">&lt;/font&gt;</span> 的计算过程。只要能完全理解这幅图片，什么 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder<span class="nt">&lt;/font&gt;</span> 架构，<span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>Encoder-Decoder<span class="nt">&lt;/font&gt;</span> 架构，什么输入层补零，逐层补零都不是问题，可以做到 “一图走天下”。

在 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>CNN<span class="nt">&lt;/font&gt;</span> 的基础上能构建的网络形式有很多，比如设置 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>stride&gt;1，dilation&gt;1<span class="nt">&lt;/font&gt;</span>，比如网络中加入残差链接等。在 <span class="nt">&lt;font</span> <span class="na">face=</span><span class="s">"Times New Roman"</span><span class="nt">&gt;</span>coding<span class="nt">&lt;/font&gt;</span> 的过程中，需要认真分析搭建的网络结构，以正确地控制网络的因果性和感受野。
</code></pre></div></div>]]></content><author><name></name></author><category term="神经网络"/><category term="卷积神经网络"/><category term="CNN"/><summary type="html"><![CDATA[本文对笔者关于 CNN 因果性的理解作以记录。如有表述不当之处欢迎批评指正。欢迎任何形式的转载，但请务必注明出处]]></summary></entry><entry><title type="html">a post with image galleries</title><link href="https://xinleiren.github.io/blog/2024/photo-gallery/" rel="alternate" type="text/html" title="a post with image galleries"/><published>2024-12-04T01:59:00+00:00</published><updated>2024-12-04T01:59:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/photo-gallery</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/photo-gallery/"><![CDATA[<p>The images in this post are all zoomable, arranged into different mini-galleries using different libraries.</p> <h2 id="lightbox2"><a href="https://lokeshdhakar.com/projects/lightbox2/">Lightbox2</a></h2> <p><a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/></a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/></a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg" data-lightbox="roadtrip"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/></a></p> <hr/> <h2 id="photoswipe"><a href="https://photoswipe.com/">PhotoSwipe</a></h2> <div class="pswp-gallery pswp-gallery--single-column" id="gallery--getting-started"> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg" data-pswp-width="1669" data-pswp-height="2500" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg" alt=""/> </a> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/7/img-2500.jpg" data-pswp-width="1875" data-pswp-height="2500" data-cropped="true" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/7/img-200.jpg" alt=""/> </a> <a href="https://unsplash.com" data-pswp-src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg" data-pswp-width="2500" data-pswp-height="1666" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg" alt=""/> </a> <div> <a href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-2500.jpg" data-pswp-width="2500" data-pswp-height="1667" target="_blank"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-200.jpg" alt=""/> </a> </div> </div> <hr/> <h2 id="spotlight-js"><a href="https://nextapps-de.github.io/spotlight/">Spotlight JS</a></h2> <div class="spotlight-group"> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/> </a> </div> <div class="spotlight-group"> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/4/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/4/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/5/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/5/img-200.jpg"/> </a> <a class="spotlight" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-2500.jpg"> <img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/6/img-200.jpg"/> </a> </div> <hr/> <h2 id="venobox"><a href="https://veno.es/venobox/">Venobox</a></h2> <p><a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/1/img-200.jpg"/></a> <a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/2/img-200.jpg"/></a> <a class="venobox" data-gall="myGallery" href="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-2500.jpg"><img src="https://cdn.photoswipe.com/photoswipe-demo-images/photos/3/img-200.jpg"/></a></p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="images"/><summary type="html"><![CDATA[this is what included image galleries could look like]]></summary></entry><entry><title type="html">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</title><link href="https://xinleiren.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/" rel="alternate" type="text/html" title="Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[We’re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.]]></summary></entry><entry><title type="html">a post with tabs</title><link href="https://xinleiren.github.io/blog/2024/tabs/" rel="alternate" type="text/html" title="a post with tabs"/><published>2024-05-01T00:32:13+00:00</published><updated>2024-05-01T00:32:13+00:00</updated><id>https://xinleiren.github.io/blog/2024/tabs</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/tabs/"><![CDATA[<p>This is how a post with <a href="https://github.com/Ovski4/jekyll-tabs">tabs</a> looks like. Note that the tabs could be used for different purposes, not only for code.</p> <h2 id="first-tabs">First tabs</h2> <p>To add tabs, use the following syntax:</p> <div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{%</span><span class="w"> </span><span class="nt">tabs</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">tab</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="nv">tab-name-1</span><span class="w"> </span><span class="cp">%}</span>

Content 1

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtab</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">tab</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="nv">tab-name-2</span><span class="w"> </span><span class="cp">%}</span>

Content 2

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtab</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtabs</span><span class="w"> </span><span class="cp">%}</span>
</code></pre></div></div> <p>With this you can generate visualizations like:</p> <ul id="log" class="tab" data-tab="906fb1d3-2285-4b8f-a391-b5692db99004" data-name="log"> <li class="active" id="log-php"> <a href="#">php </a> </li> <li id="log-js"> <a href="#">js </a> </li> <li id="log-ruby"> <a href="#">ruby </a> </li> </ul> <ul class="tab-content" id="906fb1d3-2285-4b8f-a391-b5692db99004" data-name="log"> <li class="active"> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">var_dump</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span>
</code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pputs</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
</code></pre></div></div> </li> </ul> <h2 id="another-example">Another example</h2> <ul id="data-struct" class="tab" data-tab="c36cb515-56c9-457f-b224-55fa25242140" data-name="data-struct"> <li class="active" id="data-struct-yaml"> <a href="#">yaml </a> </li> <li id="data-struct-json"> <a href="#">json </a> </li> </ul> <ul class="tab-content" id="c36cb515-56c9-457f-b224-55fa25242140" data-name="data-struct"> <li class="active"> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">hello</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">whatsup"</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">hi"</span>
</code></pre></div></div> </li> <li> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"hello"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"whatsup"</span><span class="p">,</span><span class="w"> </span><span class="s2">"hi"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> </li> </ul> <h2 id="tabs-for-something-else">Tabs for something else</h2> <ul id="something-else" class="tab" data-tab="d93b8de4-2ad7-4bfb-8031-22aa2fbdccd5" data-name="something-else"> <li class="active" id="something-else-text"> <a href="#">text </a> </li> <li id="something-else-quote"> <a href="#">quote </a> </li> <li id="something-else-list"> <a href="#">list </a> </li> </ul> <ul class="tab-content" id="d93b8de4-2ad7-4bfb-8031-22aa2fbdccd5" data-name="something-else"> <li class="active"> <p>Regular text</p> </li> <li> <blockquote> <p>A quote</p> </blockquote> </li> <li> <p>Hipster list</p> <ul> <li>brunch</li> <li>fixie</li> <li>raybans</li> <li>messenger bag</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included tabs in a post could look like]]></summary></entry><entry><title type="html">a post with typograms</title><link href="https://xinleiren.github.io/blog/2024/typograms/" rel="alternate" type="text/html" title="a post with typograms"/><published>2024-04-29T23:36:10+00:00</published><updated>2024-04-29T23:36:10+00:00</updated><id>https://xinleiren.github.io/blog/2024/typograms</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/typograms/"><![CDATA[<p>This is an example post with some <a href="https://github.com/google/typograms/">typograms</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">typograms
</span><span class="sb">+----+
|    |---&gt; My first diagram!
+----+</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <pre><code class="language-typograms">+----+
|    |---&gt; My first diagram!
+----+
</code></pre> <p>Another example:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">typograms
</span><span class="sb">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.</span>
<span class="p">```</span>
</code></pre></div></div> <p>which generates:</p> <pre><code class="language-typograms">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.
</code></pre> <p>For more examples, check out the <a href="https://google.github.io/typograms/#examples">typograms documentation</a>.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="diagrams"/><summary type="html"><![CDATA[this is what included typograms code could look like]]></summary></entry><entry><title type="html">a post that can be cited</title><link href="https://xinleiren.github.io/blog/2024/post-citation/" rel="alternate" type="text/html" title="a post that can be cited"/><published>2024-04-28T15:06:00+00:00</published><updated>2024-04-28T15:06:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/post-citation</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/post-citation/"><![CDATA[<p>This is an example post that can be cited. The content of the post ends here, while the citation information is automatically provided below. The only thing needed is for you to set the <code class="language-plaintext highlighter-rouge">citation</code> key in the front matter to <code class="language-plaintext highlighter-rouge">true</code>.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="citation"/><summary type="html"><![CDATA[this is what a post that can be cited looks like]]></summary></entry><entry><title type="html">a post with pseudo code</title><link href="https://xinleiren.github.io/blog/2024/pseudocode/" rel="alternate" type="text/html" title="a post with pseudo code"/><published>2024-04-15T00:01:00+00:00</published><updated>2024-04-15T00:01:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/pseudocode</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/pseudocode/"><![CDATA[<p>This is an example post with some pseudo code rendered by <a href="https://github.com/SaswatPadhi/pseudocode.js">pseudocode</a>. The example presented here is the same as the one in the <a href="https://saswat.padhi.me/pseudocode.js/">pseudocode.js</a> documentation, with only one simple but important change: everytime you would use <code class="language-plaintext highlighter-rouge">$</code>, you should use <code class="language-plaintext highlighter-rouge">$$</code> instead. Also, note that the <code class="language-plaintext highlighter-rouge">pseudocode</code> key in the front matter is set to <code class="language-plaintext highlighter-rouge">true</code> to enable the rendering of pseudo code. As an example, using this code:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">pseudocode
</span><span class="sb">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}</span>
<span class="p">```</span>
</code></pre></div></div> <p>Generates:</p> <pre><code class="language-pseudocode">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included pseudo code could look like]]></summary></entry><entry><title type="html">a post with code diff</title><link href="https://xinleiren.github.io/blog/2024/code-diff/" rel="alternate" type="text/html" title="a post with code diff"/><published>2024-01-27T19:22:00+00:00</published><updated>2024-01-27T19:22:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/code-diff</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/code-diff/"><![CDATA[<p>You can display diff code by using the regular markdown syntax:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">diff
</span><span class="gh">diff --git a/sample.js b/sample.js
index 0000001..0ddf2ba
</span><span class="gd">--- a/sample.js
</span><span class="gi">+++ b/sample.js
</span><span class="p">@@ -1 +1 @@</span>
<span class="gd">-console.log("Hello World!")
</span><span class="gi">+console.log("Hello from Diff2Html!")</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/sample.js b/sample.js
index 0000001..0ddf2ba
</span><span class="gd">--- a/sample.js
</span><span class="gi">+++ b/sample.js
</span><span class="p">@@ -1 +1 @@</span>
<span class="gd">-console.log("Hello World!")
</span><span class="gi">+console.log("Hello from Diff2Html!")
</span></code></pre></div></div> <p>But this is difficult to read, specially if you have a large diff. You can use <a href="https://diff2html.xyz/">diff2html</a> to display a more readable version of the diff. For this, just use <code class="language-plaintext highlighter-rouge">diff2html</code> instead of <code class="language-plaintext highlighter-rouge">diff</code> for the code block language:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">diff2html
</span><span class="sb">diff --git a/sample.js b/sample.js
index 0000001..0ddf2ba
--- a/sample.js
+++ b/sample.js
@@ -1 +1 @@
-console.log("Hello World!")
+console.log("Hello from Diff2Html!")</span>
<span class="p">```</span>
</code></pre></div></div> <p>If we use a longer example, for example <a href="https://github.com/rtfpessoa/diff2html/commit/c2c253d3e3f8b8b267f551e659f72b44ca2ac927">this commit from diff2html</a>, it will generate the following output:</p> <pre><code class="language-diff2html">From 2aaae31cc2a37bfff83430c2c914b140bee59b6a Mon Sep 17 00:00:00 2001
From: Rodrigo Fernandes &lt;rtfrodrigo@gmail.com&gt;
Date: Sun, 9 Oct 2016 16:41:54 +0100
Subject: [PATCH 1/2] Initial template override support

---
 scripts/hulk.js                    |  4 ++--
 src/diff2html.js                   |  3 +--
 src/file-list-printer.js           | 11 ++++++++---
 src/hoganjs-utils.js               | 29 +++++++++++++++++------------
 src/html-printer.js                |  6 ++++++
 src/line-by-line-printer.js        |  6 +++++-
 src/side-by-side-printer.js        |  6 +++++-
 test/file-list-printer-tests.js    |  2 +-
 test/hogan-cache-tests.js          | 18 +++++++++++++++---
 test/line-by-line-tests.js         |  3 +--
 test/side-by-side-printer-tests.js |  3 +--
 11 files changed, 62 insertions(+), 29 deletions(-)

diff --git a/scripts/hulk.js b/scripts/hulk.js
index 5a793c18..a4b1a4d5 100755
--- a/scripts/hulk.js
+++ b/scripts/hulk.js
@@ -173,11 +173,11 @@ function namespace(name) {
 // write a template foreach file that matches template extension
 templates = extractFiles(options.argv.remain)
   .map(function(file) {
-    var openedFile = fs.readFileSync(file, 'utf-8');
+    var openedFile = fs.readFileSync(file, 'utf-8').trim();
     var name;
     if (!openedFile) return;
     name = namespace(path.basename(file).replace(/\..*$/, ''));
-    openedFile = removeByteOrderMark(openedFile.trim());
+    openedFile = removeByteOrderMark(openedFile);
     openedFile = wrap(file, name, openedFile);
     if (!options.outputdir) return openedFile;
     fs.writeFileSync(path.join(options.outputdir, name + '.js')
diff --git a/src/diff2html.js b/src/diff2html.js
index 21b0119e..64e138f5 100644
--- a/src/diff2html.js
+++ b/src/diff2html.js
@@ -7,7 +7,6 @@

 (function() {
   var diffParser = require('./diff-parser.js').DiffParser;
-  var fileLister = require('./file-list-printer.js').FileListPrinter;
   var htmlPrinter = require('./html-printer.js').HtmlPrinter;

   function Diff2Html() {
@@ -43,7 +42,7 @@

     var fileList = '';
     if (configOrEmpty.showFiles === true) {
-      fileList = fileLister.generateFileList(diffJson, configOrEmpty);
+      fileList = htmlPrinter.generateFileListSummary(diffJson, configOrEmpty);
     }

     var diffOutput = '';
diff --git a/src/file-list-printer.js b/src/file-list-printer.js
index e408d9b2..1e0a2c61 100644
--- a/src/file-list-printer.js
+++ b/src/file-list-printer.js
@@ -8,11 +8,16 @@
 (function() {
   var printerUtils = require('./printer-utils.js').PrinterUtils;

-  var hoganUtils = require('./hoganjs-utils.js').HoganJsUtils;
+  var hoganUtils;
+
   var baseTemplatesPath = 'file-summary';
   var iconsBaseTemplatesPath = 'icon';

-  function FileListPrinter() {
+  function FileListPrinter(config) {
+    this.config = config;
+
+    var HoganJsUtils = require('./hoganjs-utils.js').HoganJsUtils;
+    hoganUtils = new HoganJsUtils(config);
   }

   FileListPrinter.prototype.generateFileList = function(diffFiles) {
@@ -38,5 +43,5 @@
     });
   };

-  module.exports.FileListPrinter = new FileListPrinter();
+  module.exports.FileListPrinter = FileListPrinter;
 })();
diff --git a/src/hoganjs-utils.js b/src/hoganjs-utils.js
index 9949e5fa..0dda08d7 100644
--- a/src/hoganjs-utils.js
+++ b/src/hoganjs-utils.js
@@ -8,18 +8,19 @@
 (function() {
   var fs = require('fs');
   var path = require('path');
-
   var hogan = require('hogan.js');

   var hoganTemplates = require('./templates/diff2html-templates.js');

-  var templatesPath = path.resolve(__dirname, 'templates');
+  var extraTemplates;

-  function HoganJsUtils() {
+  function HoganJsUtils(configuration) {
+    this.config = configuration || {};
+    extraTemplates = this.config.templates || {};
   }

-  HoganJsUtils.prototype.render = function(namespace, view, params, configuration) {
-    var template = this.template(namespace, view, configuration);
+  HoganJsUtils.prototype.render = function(namespace, view, params) {
+    var template = this.template(namespace, view);
     if (template) {
       return template.render(params);
     }
@@ -27,17 +28,16 @@
     return null;
   };

-  HoganJsUtils.prototype.template = function(namespace, view, configuration) {
-    var config = configuration || {};
+  HoganJsUtils.prototype.template = function(namespace, view) {
     var templateKey = this._templateKey(namespace, view);

-    return this._getTemplate(templateKey, config);
+    return this._getTemplate(templateKey);
   };

-  HoganJsUtils.prototype._getTemplate = function(templateKey, config) {
+  HoganJsUtils.prototype._getTemplate = function(templateKey) {
     var template;

-    if (!config.noCache) {
+    if (!this.config.noCache) {
       template = this._readFromCache(templateKey);
     }

@@ -53,6 +53,7 @@

     try {
       if (fs.readFileSync) {
+        var templatesPath = path.resolve(__dirname, 'templates');
         var templatePath = path.join(templatesPath, templateKey);
         var templateContent = fs.readFileSync(templatePath + '.mustache', 'utf8');
         template = hogan.compile(templateContent);
@@ -66,12 +67,16 @@
   };

   HoganJsUtils.prototype._readFromCache = function(templateKey) {
-    return hoganTemplates[templateKey];
+    return extraTemplates[templateKey] || hoganTemplates[templateKey];
   };

   HoganJsUtils.prototype._templateKey = function(namespace, view) {
     return namespace + '-' + view;
   };

-  module.exports.HoganJsUtils = new HoganJsUtils();
+  HoganJsUtils.prototype.compile = function(templateStr) {
+    return hogan.compile(templateStr);
+  };
+
+  module.exports.HoganJsUtils = HoganJsUtils;
 })();
diff --git a/src/html-printer.js b/src/html-printer.js
index 585d5b66..13f83047 100644
--- a/src/html-printer.js
+++ b/src/html-printer.js
@@ -8,6 +8,7 @@
 (function() {
   var LineByLinePrinter = require('./line-by-line-printer.js').LineByLinePrinter;
   var SideBySidePrinter = require('./side-by-side-printer.js').SideBySidePrinter;
+  var FileListPrinter = require('./file-list-printer.js').FileListPrinter;

   function HtmlPrinter() {
   }
@@ -22,5 +23,10 @@
     return sideBySidePrinter.generateSideBySideJsonHtml(diffFiles);
   };

+  HtmlPrinter.prototype.generateFileListSummary = function(diffJson, config) {
+    var fileListPrinter = new FileListPrinter(config);
+    return fileListPrinter.generateFileList(diffJson);
+  };
+
   module.exports.HtmlPrinter = new HtmlPrinter();
 })();
diff --git a/src/line-by-line-printer.js b/src/line-by-line-printer.js
index b07eb53c..d230bedd 100644
--- a/src/line-by-line-printer.js
+++ b/src/line-by-line-printer.js
@@ -11,7 +11,8 @@
   var utils = require('./utils.js').Utils;
   var Rematch = require('./rematch.js').Rematch;

-  var hoganUtils = require('./hoganjs-utils.js').HoganJsUtils;
+  var hoganUtils;
+
   var genericTemplatesPath = 'generic';
   var baseTemplatesPath = 'line-by-line';
   var iconsBaseTemplatesPath = 'icon';
@@ -19,6 +20,9 @@

   function LineByLinePrinter(config) {
     this.config = config;
+
+    var HoganJsUtils = require('./hoganjs-utils.js').HoganJsUtils;
+    hoganUtils = new HoganJsUtils(config);
   }

   LineByLinePrinter.prototype.makeFileDiffHtml = function(file, diffs) {
diff --git a/src/side-by-side-printer.js b/src/side-by-side-printer.js
index bbf1dc8d..5e3033b3 100644
--- a/src/side-by-side-printer.js
+++ b/src/side-by-side-printer.js
@@ -11,7 +11,8 @@
   var utils = require('./utils.js').Utils;
   var Rematch = require('./rematch.js').Rematch;

-  var hoganUtils = require('./hoganjs-utils.js').HoganJsUtils;
+  var hoganUtils;
+
   var genericTemplatesPath = 'generic';
   var baseTemplatesPath = 'side-by-side';
   var iconsBaseTemplatesPath = 'icon';
@@ -26,6 +27,9 @@

   function SideBySidePrinter(config) {
     this.config = config;
+
+    var HoganJsUtils = require('./hoganjs-utils.js').HoganJsUtils;
+    hoganUtils = new HoganJsUtils(config);
   }

   SideBySidePrinter.prototype.makeDiffHtml = function(file, diffs) {
diff --git a/test/file-list-printer-tests.js b/test/file-list-printer-tests.js
index a502a46f..60ea3208 100644
--- a/test/file-list-printer-tests.js
+++ b/test/file-list-printer-tests.js
@@ -1,6 +1,6 @@
 var assert = require('assert');

-var fileListPrinter = require('../src/file-list-printer.js').FileListPrinter;
+var fileListPrinter = new (require('../src/file-list-printer.js').FileListPrinter)();

 describe('FileListPrinter', function() {
   describe('generateFileList', function() {
diff --git a/test/hogan-cache-tests.js b/test/hogan-cache-tests.js
index 190bf6f8..3bb754ac 100644
--- a/test/hogan-cache-tests.js
+++ b/test/hogan-cache-tests.js
@@ -1,6 +1,6 @@
 var assert = require('assert');

-var HoganJsUtils = require('../src/hoganjs-utils.js').HoganJsUtils;
+var HoganJsUtils = new (require('../src/hoganjs-utils.js').HoganJsUtils)();
 var diffParser = require('../src/diff-parser.js').DiffParser;

 describe('HoganJsUtils', function() {
@@ -21,16 +21,28 @@ describe('HoganJsUtils', function() {
       });
       assert.equal(emptyDiffHtml, result);
     });
+
     it('should render view without cache', function() {
       var result = HoganJsUtils.render('generic', 'empty-diff', {
         contentClass: 'd2h-code-line',
         diffParser: diffParser
       }, {noCache: true});
-      assert.equal(emptyDiffHtml + '\n', result);
+      assert.equal(emptyDiffHtml, result);
     });
+
     it('should return null if template is missing', function() {
-      var result = HoganJsUtils.render('generic', 'missing-template', {}, {noCache: true});
+      var hoganUtils = new (require('../src/hoganjs-utils.js').HoganJsUtils)({noCache: true});
+      var result = hoganUtils.render('generic', 'missing-template', {});
       assert.equal(null, result);
     });
+
+    it('should allow templates to be overridden', function() {
+      var emptyDiffTemplate = HoganJsUtils.compile('&lt;p&gt;&lt;/p&gt;');
+
+      var config = {templates: {'generic-empty-diff': emptyDiffTemplate}};
+      var hoganUtils = new (require('../src/hoganjs-utils.js').HoganJsUtils)(config);
+      var result = hoganUtils.render('generic', 'empty-diff', {myName: 'Rodrigo Fernandes'});
+      assert.equal('&lt;p&gt;Rodrigo Fernandes&lt;/p&gt;', result);
+    });
   });
 });
diff --git a/test/line-by-line-tests.js b/test/line-by-line-tests.js
index 1cd92073..8869b3df 100644
--- a/test/line-by-line-tests.js
+++ b/test/line-by-line-tests.js
@@ -14,7 +14,7 @@ describe('LineByLinePrinter', function() {
         '            File without changes\n' +
         '        &lt;/div&gt;\n' +
         '    &lt;/td&gt;\n' +
-        '&lt;/tr&gt;\n';
+        '&lt;/tr&gt;';

       assert.equal(expected, fileHtml);
     });
@@ -422,7 +422,6 @@ describe('LineByLinePrinter', function() {
         '        &lt;/div&gt;\n' +
         '    &lt;/td&gt;\n' +
         '&lt;/tr&gt;\n' +
-        '\n' +
         '                &lt;/tbody&gt;\n' +
         '            &lt;/table&gt;\n' +
         '        &lt;/div&gt;\n' +
diff --git a/test/side-by-side-printer-tests.js b/test/side-by-side-printer-tests.js
index 76625f8e..771daaa5 100644
--- a/test/side-by-side-printer-tests.js
+++ b/test/side-by-side-printer-tests.js
@@ -14,7 +14,7 @@ describe('SideBySidePrinter', function() {
         '            File without changes\n' +
         '        &lt;/div&gt;\n' +
         '    &lt;/td&gt;\n' +
-        '&lt;/tr&gt;\n';
+        '&lt;/tr&gt;';

       assert.equal(expectedRight, fileHtml.right);
       assert.equal(expectedLeft, fileHtml.left);
@@ -324,7 +324,6 @@ describe('SideBySidePrinter', function() {
         '        &lt;/div&gt;\n' +
         '    &lt;/td&gt;\n' +
         '&lt;/tr&gt;\n' +
-        '\n' +
         '                    &lt;/tbody&gt;\n' +
         '                &lt;/table&gt;\n' +
         '            &lt;/div&gt;\n' +

From f3cadb96677d0eb82fc2752dc3ffbf35ca9b5bdb Mon Sep 17 00:00:00 2001
From: Rodrigo Fernandes &lt;rtfrodrigo@gmail.com&gt;
Date: Sat, 15 Oct 2016 13:21:22 +0100
Subject: [PATCH 2/2] Allow uncompiled templates

---
 README.md                 |  3 +++
 src/hoganjs-utils.js      |  7 +++++++
 test/hogan-cache-tests.js | 24 +++++++++++++++++++++++-
 3 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 132c8a28..46909f25 100644
--- a/README.md
+++ b/README.md
@@ -98,6 +98,9 @@ The HTML output accepts a Javascript object with configuration. Possible options
   - `synchronisedScroll`: scroll both panes in side-by-side mode: `true` or `false`, default is `false`
   - `matchWordsThreshold`: similarity threshold for word matching, default is 0.25
   - `matchingMaxComparisons`: perform at most this much comparisons for line matching a block of changes, default is `2500`
+  - `templates`: object with previously compiled templates to replace parts of the html
+  - `rawTemplates`: object with raw not compiled templates to replace parts of the html
+  &gt; For more information regarding the possible templates look into [src/templates](https://github.com/rtfpessoa/diff2html/tree/master/src/templates)

 ## Diff2HtmlUI Helper

diff --git a/src/hoganjs-utils.js b/src/hoganjs-utils.js
index 0dda08d7..b2e9c275 100644
--- a/src/hoganjs-utils.js
+++ b/src/hoganjs-utils.js
@@ -17,6 +17,13 @@
   function HoganJsUtils(configuration) {
     this.config = configuration || {};
     extraTemplates = this.config.templates || {};
+
+    var rawTemplates = this.config.rawTemplates || {};
+    for (var templateName in rawTemplates) {
+      if (rawTemplates.hasOwnProperty(templateName)) {
+        if (!extraTemplates[templateName]) extraTemplates[templateName] = this.compile(rawTemplates[templateName]);
+      }
+    }
   }

   HoganJsUtils.prototype.render = function(namespace, view, params) {
diff --git a/test/hogan-cache-tests.js b/test/hogan-cache-tests.js
index 3bb754ac..a34839c0 100644
--- a/test/hogan-cache-tests.js
+++ b/test/hogan-cache-tests.js
@@ -36,7 +36,7 @@ describe('HoganJsUtils', function() {
       assert.equal(null, result);
     });

-    it('should allow templates to be overridden', function() {
+    it('should allow templates to be overridden with compiled templates', function() {
       var emptyDiffTemplate = HoganJsUtils.compile('&lt;p&gt;&lt;/p&gt;');

       var config = {templates: {'generic-empty-diff': emptyDiffTemplate}};
@@ -44,5 +44,27 @@ describe('HoganJsUtils', function() {
       var result = hoganUtils.render('generic', 'empty-diff', {myName: 'Rodrigo Fernandes'});
       assert.equal('&lt;p&gt;Rodrigo Fernandes&lt;/p&gt;', result);
     });
+
+    it('should allow templates to be overridden with uncompiled templates', function() {
+      var emptyDiffTemplate = '&lt;p&gt;&lt;/p&gt;';
+
+      var config = {rawTemplates: {'generic-empty-diff': emptyDiffTemplate}};
+      var hoganUtils = new (require('../src/hoganjs-utils.js').HoganJsUtils)(config);
+      var result = hoganUtils.render('generic', 'empty-diff', {myName: 'Rodrigo Fernandes'});
+      assert.equal('&lt;p&gt;Rodrigo Fernandes&lt;/p&gt;', result);
+    });
+
+    it('should allow templates to be overridden giving priority to compiled templates', function() {
+      var emptyDiffTemplate = HoganJsUtils.compile('&lt;p&gt;&lt;/p&gt;');
+      var emptyDiffTemplateUncompiled = '&lt;p&gt;Not used!&lt;/p&gt;';
+
+      var config = {
+        templates: {'generic-empty-diff': emptyDiffTemplate},
+        rawTemplates: {'generic-empty-diff': emptyDiffTemplateUncompiled}
+      };
+      var hoganUtils = new (require('../src/hoganjs-utils.js').HoganJsUtils)(config);
+      var result = hoganUtils.render('generic', 'empty-diff', {myName: 'Rodrigo Fernandes'});
+      assert.equal('&lt;p&gt;Rodrigo Fernandes&lt;/p&gt;', result);
+    });
   });
 });
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is how you can display code diffs]]></summary></entry><entry><title type="html">a post with advanced image components</title><link href="https://xinleiren.github.io/blog/2024/advanced-images/" rel="alternate" type="text/html" title="a post with advanced image components"/><published>2024-01-27T11:46:00+00:00</published><updated>2024-01-27T11:46:00+00:00</updated><id>https://xinleiren.github.io/blog/2024/advanced-images</id><content type="html" xml:base="https://xinleiren.github.io/blog/2024/advanced-images/"><![CDATA[<p>This is an example post with advanced image components.</p> <h2 id="image-slider">Image Slider</h2> <p>This is a simple image slider. It uses the <a href="https://swiperjs.com/">Swiper</a> library. Check the <a href="https://swiperjs.com/demos">examples page</a> for more information of what you can achieve with it.</p> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/9-480.webp 480w,/assets/img/9-800.webp 800w,/assets/img/9-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/9.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/7-480.webp 480w,/assets/img/7-800.webp 800w,/assets/img/7-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/7.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/8-480.webp 480w,/assets/img/8-800.webp 800w,/assets/img/8-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/8.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/10-480.webp 480w,/assets/img/10-800.webp 800w,/assets/img/10-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/10.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/12-480.webp 480w,/assets/img/12-800.webp 800w,/assets/img/12-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/12.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <h2 id="image-comparison-slider">Image Comparison Slider</h2> <p>This is a simple image comparison slider. It uses the <a href="https://img-comparison-slider.sneas.io/">img-comparison-slider</a> library. Check the <a href="https://img-comparison-slider.sneas.io/examples.html">examples page</a> for more information of what you can achieve with it.</p> <img-comparison-slider> <figure slot="first"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/prof_pic-480.webp 480w,/assets/img/prof_pic-800.webp 800w,/assets/img/prof_pic-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/prof_pic.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure slot="second"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/prof_pic_color-480.webp 480w,/assets/img/prof_pic_color-800.webp 800w,/assets/img/prof_pic_color-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/prof_pic_color.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </img-comparison-slider>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="images"/><summary type="html"><![CDATA[this is what advanced image components could look like]]></summary></entry></feed>